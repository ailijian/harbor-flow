# HarborFlow v1.0.0 设计蓝图

> 让“写 LangGraph 图”变成“写普通 Python 函数”

---

## 0. 文档定位

* **身份**：HarborFlow v1.0.0 的「产品 / 概念设计蓝图」，是后续技术架构文档的**唯一事实来源**。
* **目标读者**：

  * 使用 LangGraph（一类图编排引擎）的应用开发者；
  * 负责 DX / 基础设施的工程师；
  * Harbor 生态中的 Context Architect。
* **不包含内容**：

  * 具体代码实现、模块划分、类图、异常类型等技术细节；
  * 任意底层库的具体版本号、内部 API 形态。

---

## 1. 背景与问题

### 1.1 现状：图编排引擎的 DX 痛点

以 LangGraph 这类有状态图编排引擎为代表，已经能很好地解决：

* 有状态对话、工具调用、Agent 协作等**复杂控制流**；
* 状态回放、检查点、可视化等**生产级能力**。

但在实际使用中，开发者仍然面临几个典型问题：

1. **心智模型割裂**

   * 一个是“我写的业务函数”，一个是“我用 API 拼出的图结构”，
   * 需要在脑中来回翻译：“这个节点函数对应哪个 add_node？这个分支对应哪个 add_edge？”

2. **样板代码多，入门门槛高**

   * 简单的两三步流程，也要显式写 builder / `add_node` / `add_edge` / `compile`；
   * 新手往往还没开始写业务逻辑，就先被“图 API”吓退。

3. **路由逻辑分散**

   * 有的在条件回调函数里（例如 should_continue）；
   * 有的隐含在 edge 配置里；
   * 很难“一眼看懂”流程真正是怎么走的。

4. **对 vibe coding / LLM 驱动开发不够友好**

   * 要不断跟 AI 解释“图是怎么拼的”、`add_node`/`add_edge` 的用法；
   * 无形中增加了提示词和上下文的复杂度，影响自动化代码生成质量。

### 1.2 HarborFlow 的定位

> **HarborFlow 是一种“类装饰器层的语法糖”，让开发者只需要写“普通 Python 类 + 普通方法”，就能自动得到一张可运行的图。**

更通俗一点：

* **图 = 被 `@graph` 装饰的类**
* **节点 = 类里面被 `@node` 标记的方法**
* **流程 = 每个节点函数 `return Route(...)` 的决定**

HarborFlow **不取代** 底层图引擎，只做一层非常薄的 DX 包装：

* 不重新造 router / scheduler / checkpointer；
* 不篡改底层的状态模型、类型系统；
* 只负责：

  * 把“类 + 方法”编译成一张图；
  * 提供统一的“返回即路由”心智模型；
  * 让 LLM / 人类都更容易读、写和维护。

---

## 2. 设计目标

### 2.1 核心目标

1. **把“写图”退化成“写类 + 写函数”**
   开发者只需要关心：

   * state 是什么结构；
   * 每个节点函数的输入/输出是什么；
   * 这个节点结束后应该跳到谁（或者结束）。

2. **统一的“返回即路由”心智模型**

   * 每个节点函数**必须返回 Route 对象**（官方规范层面）；
   * Route 里总是只有两件事情：

     * 这一步**如何更新 state**；
     * 下一步**要去哪个节点 / 是否结束**。

3. **与底层图引擎保持 100% 兼容与透明**

   * HarborFlow 不重新设计状态合并、消息累积、检查点、流式输出机制；
   * 仅在最外层「描述图」与「描述节点行为」的地方做封装；
   * 保证：熟悉底层图引擎的人，一眼就能理解 HarborFlow 在做什么。

4. **天然适配 vibe coding / LLM 助手**

   * 对 LLM 来说，“类 + 方法 + docstring”是最自然的上下文；
   * 通过简单的注释，就可以让 AI 在不碰 `add_node` / `add_edge` 的前提下维护整个流程；
   * 为 Harbor-spec / L3 文档驱动的开发方式预留接口。

### 2.2 非目标（v1.0 不做的事情）

1. **不重新实现路由/调度引擎**

   * 不实现自己的“条件边系统”、“循环检测引擎”、“事件总线”等；
   * 全部依赖底层图引擎的既有能力。

2. **不引入复杂 DSL**

   * 不在 v1.0 提供 Guard DSL / 错误处理 DSL / 配置语言；
   * 节点内的控制逻辑全部用普通 Python 表达。

3. **不做运行时的重型魔法**

   * 不做深度状态冻结、侵入式类型检查、自动重试策略；
   * 保持运行时轻量，便于调试。

---

## 3. 核心心智模型

### 3.1 三个关键抽象

1. **Graph（图）**

   * 由 `@graph` 装饰的类代表一张图；
   * 类本身只负责描述：

     * 使用什么 state 结构；
     * 哪个节点是入口；
     * 哪些节点是「自然结束点」（可选）；
     * 是否需要 context 等高级特性。

2. **Node（节点）**

   * 被 `@node` 装饰的实例方法或类方法；
   * 每个节点函数：

     * 接收当前 state（以及可选的 runtime / context）；
     * 返回一个 Route（必须）；
     * 由 Route 决定更新 state 与下一步去哪里。

3. **Route（路由决策）**

   * Route 是对底层“路由指令对象”的直观别名；
   * 语义固定为两部分：

     * `update`：对 state 的变更（可以是局部更新）；
     * `goto`：下一个要执行的节点名，或特殊的结束标识。

### 3.2 两个阶段：编译与运行

HarborFlow 故意保留与底层图引擎相同的分层方式：

1. **编译阶段（构建图）**

   ```python
   app = ChatFlow().compile(...)
   ```

   * 由 `compile()` 完成从“类 + @node 方法”到「可运行图实例」的转换；
   * 这个阶段可以：

     * 注册所有节点；
     * 做基本校验（入口节点是否存在等）；
     * 注入检查点、观测、追踪等运行能力。

2. **运行阶段（执行图）**

   ```python
   result = app.invoke(initial_state)
   ```

   * `invoke()` 接收初始 state；
   * 按图与 Route 决定的流程执行节点；
   * 产出最终 state（或流式中间状态）。

> 设计选择：
> HarborFlow v1.0 不增加**额外的快速运行语法糖**（例如 `ChatFlow.run(...)`），以保持和底层图引擎的 mental model 一致：
> “**先构建图，再反复运行图**”。

---

## 4. 使用者视角：HarborFlow 的开发体验

### 4.1 开发者需要学习的最小概念集合

使用 HarborFlow，开发者只需要掌握三件事：

1. **如何声明 state**

   * state 是整个图中共享的“事实载体”；
   * 可以用 TypedDict / Pydantic 等结构来定义字段；
   * 某些字段可以使用底层图引擎提供的“reducer/累积策略”注解（例如消息列表自动追加）。

2. **如何写一个节点函数**

   * 签名：`def node_name(self, state: State, ...) -> Route`；
   * 函数内用普通 Python 写业务逻辑；
   * 最后 `return Route(goto=..., update={...})`，表明这一步怎么更新 state、下一步去哪。

3. **如何把一组节点组成图**

   * `@graph(state=..., start="entry_node", finish=...)` 装饰类；
   * 类中用 `@node` 标注的方法名就是节点名；
   * 编译：`app = MyGraph().compile()`；
   * 运行：`app.invoke(initial_state)`。

### 4.2 典型“Hello Flow” 心智步骤

1. **想清楚：这个流程有哪几步？每一步叫啥？**
2. **用类的方法把每一步写出来，每个方法只管自己的输入/输出和下一步是谁。**
3. **给类加一个 `@graph(...)`，告诉框架入口是哪一步。**
4. **编译一次，反复运行。**

开发者完全可以**不去思考**：

* builder 内部怎么 add_node / add_edge；
* 路由选择器函数长什么样；
* 条件边、循环如何在底层被实现。

---

## 5. 核心能力（概念层）

> 本章节只描述“能力”，不展开为具体 API 签名或代码实现。

### 5.1 `@graph`：类 → 图 的映射

`@graph` 的职责是把一个普通 Python 类，解释为一张可执行的图：

* **输入信息（由装饰器参数提供）**：

  * state 的类型/结构；
  * 入口节点名；
  * 可选的「结束节点名」；
  * 可选的 context 结构（比如运行时配置、请求级上下文）；
  * 可选的图名称/标识，用于日志与可视化。

* **运行时行为（对使用者可见）**：

  * 在类上注入一个 `.compile(...)` 方法；
  * `compile()` 返回一个可以 `.invoke(...)` / `.ainvoke(...)` / `.stream(...)` 的图实例。

* **不做的事情**：

  * 不强制生成复杂的拓扑结构；
  * 不在 v1.0 中引入 Guard / 错误处理 DSL；
  * 不对 state 内部字段做侵入式修改。

### 5.2 `@node`：方法 → 节点 的映射

`@node` 的职责是把一个方法标记为“图中的一个节点”：

* **输入信息**：

  * 方法名（或显式指定的节点名）；
  * 可选的节点元数据（例如业务含义、可观察性标签）；
  * 可选的执行策略（例如重试策略、超时等——由底层图引擎支持时才暴露）。

* **对开发者的约束（规范）**：

  * 节点函数应当：

    * 接收当前 state（以及可能的 runtime / context）；
    * 返回一个 Route 对象（官方教程与规范中**统一要求**）；
  * 不鼓励在节点内直接原地修改 state，而是通过 `update` 返回修改后的字段。

* **`@node` 不做的事情**：

  * 不改变函数语义；
  * 不截获异常、不自动重试（这类能力留给底层图引擎或未来版本的扩展）。

### 5.3 `Route`：统一的返回即路由

Route 是 HarborFlow 的核心 UX 抽象：

* **语义固定为两部分**：

  * `update`：一个描述“这一步要对 state 做哪些修改”的结构；
  * `goto`：下一个要执行的节点标识，或特殊的“结束”哨兵值。

* **设计要求**：

  * 所有 HarborFlow 官方文档与示例中，节点函数都**必须显式返回 Route**；
  * 这样可以保证：

    * 新人只用记住一种返回方式；
    * “返回即路由”这个规则无例外、更好讲；
    * 后续做静态分析 / 可视化 / 文档生成时，也有统一的数据源。

* **与底层图引擎的关系**：

  * Route 在概念上等价于底层的“路由指令对象”（例如 `Command`），不会引入第二套机制；
  * HarborFlow 把 Route **作为一种更贴近业务语言的别名和封装**。

---

## 6. 范围与边界（v1.0 功能矩阵）

### 6.1 v1.0 **包含** 的能力（概念级）

1. **类 → 图 的声明式映射**

   * 支持通过 `@graph` + `@node` 完整描述一个有状态流程。

2. **统一的“返回即路由”语义**

   * Route 决定状态如何更新 + 下一步去哪；
   * 所有节点返回 Route，提升一致性。

3. **与底层图引擎的运行方式保持一致**

   * 使用“先编译、后运行”的工作流；
   * 保持 `.compile().invoke()` 这一基本结构不变。

4. **状态结构的声明式定义**

   * 支持使用类型系统描述 state 结构；
   * 支持与底层图引擎的 state 合并 / reducer 概念配合使用。

5. **与 LangGraph Studio / 观测体系的自然对接（概念上）**

   * 由 HarborFlow 提供足够的节点信息和图结构信息，便于底层工具进行可视化与监控。

### 6.2 v1.0 **明确不包含** 的能力（为避免过度设计）

1. **自定义错误处理 DSL**

   * 不在 v1.0 中引入 `@error_handler`、内建错误路由等语法；
   * 节点内的错误通过普通异常 + 底层重试/中断机制处理。

2. **Guard / 条件前置检查 DSL**

   * 不提供 `@node(guards=[...])` 这种高阶语法；
   * 建议用普通 `if` + `raise` 写前置条件。

3. **自有的循环检测与限流机制**

   * 不引入 HarborFlow 自己的循环计数 / 步数限制；
   * 使用底层图引擎已有的防递归 / 步数控制机制。

4. **复杂的类型/Schema 校验器**

   * 不做运行时的强类型检查器；
   * 仅建议利用类型系统和底层引擎已有的 Schema 能力。

5. **任何与 LangGraph 内部实现强耦合的特性**

   * 不依赖某个版本的私有 API；
   * 只依托于稳定的、概念层面的“状态图 + 节点 + 路由指令”模型。

---

## 7. 典型使用场景（故事级）

> 本章节从“使用者故事”的角度描述 HarborFlow 想要支撑的主要场景，后续架构设计可以围绕这些故事展开。

### 7.1 简单线性流程

**场景**：
一个三步的业务流程：校验输入 → 调用服务 → 返回结果。没有分支，没有循环。

**开发者体验目标**：

1. 声明一个 state，包含输入与输出字段；
2. 写三个节点函数（`validate` / `call_service` / `finalize`）；
3. 在类上加 `@graph(state=..., start="validate", finish="finalize")`；
4. `app = Flow().compile()`，然后在任意地方 `app.invoke(initial_state)`。

**图的结构感受**：
看类就能看到顺序，也能从 Route.return 中直接读出每一步之后去哪。

### 7.2 条件分支与循环

**场景**：
一个对话 Agent，根据当前消息决定是否调用工具，工具调用完再回到 Agent，直到满足某个退出条件。

**HarborFlow 带来的简化**：

* `agent` 节点通过 `Route(goto="tool" / goto=END)` 决定是否进入工具调用；
* `tool` 节点通过 `Route(goto="agent")` 把控制权交回；
* 不需要显式写条件边 / 路由函数，分支逻辑都在节点代码 return 的 Route 中。

### 7.3 多 Agent 协作（多节点互相跳转）

**场景**：
多个专业 Agent（例如 Summarizer / Researcher / Critic）按照一定规则轮流工作。

**体验目标**：

* 每一个 Agent 是一个节点（或一小串节点）；
* 中控节点根据 state 决定下一个 Agent 是谁，简单地 `return Route(goto="researcher", update={...})`；
* 整个“协作协议”可以通过一个 central coordinator 节点的多个 Route 分支表达出来，一眼就能看懂。

---

## 8. 可演进方向（不属于 v1.0 规范的一部分）

> 本节仅为未来设计提供方向感，不构成 v1.0 行为约束。

未来可能出现的扩展（在 v1.0 之上）：

1. **Guard / 校验扩展包**

   * 提供 `@node(guards=[...])` 简写；
   * Guard 内部仍然只是普通函数 + 异常。

2. **错误处理模式扩展包**

   * 提供简单的 “节点级错误降级路由” 语法糖；
   * 底层仍然使用异常 + 路由指令。

3. **开发工具集成**

   * 根据 `@graph` / `@node` 自动生成可视化图谱；
   * 为 Harbor-spec 提供从节点到 L3 Spec 的自动链接。

4. **规范化的 DX 套件**

   * 推荐项目模板；
   * 推荐测试模式、日志模式；
   * 与 Harbor-spec L1/L2 宪法联动。

---

## 9. 总结：HarborFlow v1.0.0 的一句话定义

> **HarborFlow v1.0.0 是一层极薄的「类装饰器语法糖」，让开发者只需要写普通 Python 类和函数，并通过统一的 Route 返回，就能构建并运行基于图编排引擎的复杂流程。**

它的本质承诺只有三个：

1. **代码即图**：
   图结构从“类 + 方法”自然长出来，而不是手动 `add_node` / `add_edge`。

2. **返回即路由**：
   每个节点的 Route 决定「状态如何变化」与「下一步去哪」，读 return 就能读懂流程。

3. **最小侵入**：
   不重造底层引擎，只在 API 表面做减法；
   不在 v1.0 引入复杂 DSL 与运行时魔法，避免过度设计。

---
